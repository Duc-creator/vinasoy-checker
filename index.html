<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
  <title>OCR Date Checker (OpenCV.js + Template Matching)</title>
  <style>
    :root{ --w: 340px; --h: 240px; }
    body{ font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#f6f7f9; margin:0; }
    .wrap{ max-width:720px; margin:0 auto; padding:14px; }
    h1{ font-size:20px; margin:10px 0; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    label{ font-size:14px; color:#333; }
    input, select, button, textarea{ font-size:14px; padding:10px; border-radius:10px; border:1px solid #dfe3ea; background:#fff; }
    button{ cursor:pointer; border:none; background:#0a7cff; color:#fff; box-shadow:0 4px 12px rgba(10,124,255,.2); }
    button:active{ transform:translateY(1px); }
    textarea{ width:100%; min-height:120px; }
    .camera{ position:relative; display:inline-block; }
    video{ width:var(--w); height:var(--h); object-fit:cover; border-radius:12px; border:2px solid #e3e7ee; background:#000; }
    #overlay{ position:absolute; border:2px dashed rgba(255,62,62,.9); border-radius:8px; pointer-events:none; width:160px; height:56px; top:50%; left:50%; transform:translate(-50%,-50%); box-shadow:0 0 12px rgba(255,62,62,.35); }
    .mini{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:8px 0; }
    .status{ font-weight:700; font-size:16px; }
    .ok{ color:#1f9d55; } .fail{ color:#e11d48; } .muted{ color:#6b7280; font-weight:500; }
    canvas{ display:none; }
    .preview{ display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap; margin-top:8px; }
    .box{ background:#fff; border:1px solid #e5e7eb; border-radius:10px; padding:8px; }
    .box h3{ margin:0 0 6px 0; font-size:13px; color:#374151; }
    .box canvas{ display:block; width:220px; height:auto; border-radius:8px; }
    .tip{ font-size:12px; color:#6b7280; }
  </style>
</head>
<body>
<div class="wrap">
  <h1>OCR Date Checker (OpenCV.js + Template Matching)</h1>

  <div class="row">
    <label>H·∫°n d√πng (th√°ng)
      <select id="shelfLife">
        <option value="6">6</option>
        <option value="9">9</option>
        <option value="10">10</option>
      </select>
    </label>
    <label>M√£ l√¥ (3 k√Ω t·ª±)
      <input id="batchCode" maxlength="3" placeholder="VD: 086" />
    </label>
    <label>Th·ª© h√¥m nay
      <input id="weekday" readonly style="width:60px" />
    </label>
    <label class="mini"><input type="checkbox" id="singleLineCheck" /> Ch·ªâ 1 line</label>
    <label id="lineSelectWrapper" style="display:none;">Line
      <select id="lineSelect"><option>A</option><option>B</option><option>C</option><option>D</option><option>E</option><option>F</option><option>G</option><option>H</option><option>I</option></select>
    </label>
    <button id="generateBtn">T·∫°o danh s√°ch date</button>
  </div>

  <textarea id="dateList" placeholder="Danh s√°ch date code..."></textarea>

  <div class="mini">
    <button id="openBtn">B·∫≠t camera</button>
    <button id="captureBtn">üì∑ Ch·ª•p & OCR</button>
    <button id="toggleAuto">Auto Scan: OFF</button>
    <span id="loader" class="muted">Templates: ch∆∞a t·∫£i</span>
  </div>

  <div class="camera">
    <video id="video" playsinline muted></video>
    <div id="overlay" title="K√©o khung n√†y ƒë·∫øn v√πng c√≥ m√£ (gi·ªØ gi·ªØa khung)"></div>
  </div>

  <div class="mini">
    <span>K·∫øt qu·∫£:</span>
    <span id="result" class="status muted">‚Äî</span>
  </div>
  <div id="ocrText" class="tip"></div>

  <!-- Hidden canvases -->
  <canvas id="rawCanvas"></canvas>
  <canvas id="cropCanvas"></canvas>
  <canvas id="procCanvas"></canvas>

  <div class="preview">
    <div class="box"><h3>Crop</h3><canvas id="cropPreview" width="220" height="100"></canvas></div>
    <div class="box"><h3>Processed</h3><canvas id="procPreview" width="220" height="100"></canvas></div>
  </div>

  <p class="tip">M·∫πo: ƒê·∫∑t khung ƒë·ªè v·ª´a kh√≠t d√£y m√£ (v√≠ d·ª•: <b>130226 093C4</b>), gi·ªØ m√°y ch·∫Øc tay, ƒë·∫£m b·∫£o ƒë·ªß s√°ng.
  Pipeline: Gray ‚Üí Resize √ó3 ‚Üí GaussianBlur ‚Üí AdaptiveThreshold (Gaussian) ‚Üí Morphology (open) ‚Üí Unsharp ‚Üí OCR (template matching).</p>
</div>

<!-- OpenCV.js (WASM) -->
<script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()"></script>
<script>
  // ====== UI helpers ======
  const $ = (s) => document.querySelector(s);
  const video = $('#video');
  const overlay = $('#overlay');
  const resultDiv = $('#result');
  const ocrTextDiv = $('#ocrText');
  const rawCanvas = $('#rawCanvas');
  const cropCanvas = $('#cropCanvas');
  const procCanvas = $('#procCanvas');
  const cropPrev = $('#cropPreview');
  const procPrev = $('#procPreview');
  const loader = $('#loader');
  let autoScan = false, autoTimer = null;

  // Make overlay draggable on mobile
  (function makeOverlayDraggable(){
    let dragging = false, startX=0, startY=0;
    const down = (e)=>{ dragging=true; const t=e.touches?e.touches[0]:e; startX=t.clientX; startY=t.clientY; e.preventDefault(); };
    const move = (e)=>{ if(!dragging) return; const t=e.touches?e.touches[0]:e; const dx=t.clientX-startX, dy=t.clientY-startY; overlay.style.left = `calc(50% + ${dx}px)`; overlay.style.top = `calc(50% + ${dy}px)`; };
    const up = ()=> dragging=false;
    overlay.addEventListener('mousedown', down); overlay.addEventListener('touchstart', down, {passive:false});
    window.addEventListener('mousemove', move, {passive:false}); window.addEventListener('touchmove', move, {passive:false});
    window.addEventListener('mouseup', up); window.addEventListener('touchend', up);
  })();

  // Weekday
  function updateWeekday(){ const d=new Date(); const day=d.getDay(); const weekday=(day===0)?1:day+1; $('#weekday').value=weekday; }
  updateWeekday();

  // Add months adjust
  function addMonthsAdjust(date, months){ const y=date.getFullYear(); const m=date.getMonth(); const day=date.getDate(); const nm=m+months; const nd=new Date(y, nm, 1); const last=new Date(nd.getFullYear(), nd.getMonth()+1, 0).getDate(); return new Date(nd.getFullYear(), nd.getMonth(), Math.min(day,last)); }

  $('#generateBtn').addEventListener('click', ()=>{
    const batchCode = $('#batchCode').value.trim();
    const weekday = $('#weekday').value;
    const shelfMonths = parseInt($('#shelfLife').value);
    const singleLine = $('#singleLineCheck').checked;
    const line = $('#lineSelect').value;
    if(batchCode.length!==3){ alert('Nh·∫≠p m√£ l√¥ 3 k√Ω t·ª±'); return; }
    const expiry = addMonthsAdjust(new Date(), shelfMonths);
    const dd=String(expiry.getDate()).padStart(2,'0');
    const mm=String(expiry.getMonth()+1).padStart(2,'0');
    const yy=String(expiry.getFullYear()).slice(2);
    const dateCode = dd+mm+yy;
    let res='';
    if(singleLine){ res = `${dateCode} ${batchCode}${line}${weekday}`; }
    else{ ['A','B','C','D','E','F','G','H','I'].forEach(L=>res+=`${dateCode} ${batchCode}${L}${weekday}\n`); res=res.trim(); }
    $('#dateList').value = res;
  });
  $('#singleLineCheck').addEventListener('change', function(){ $('#lineSelectWrapper').style.display = this.checked? 'inline-block':'none'; });

  // ====== Camera ======
  async function openCamera(){
    try{
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: { ideal: 'environment' },
          width: { ideal: 1280 }, height: { ideal: 720 },
          advanced: [ { focusMode: 'continuous' } ]
        },
        audio:false
      });
      video.srcObject = stream; await video.play();
      rawCanvas.width = video.videoWidth; rawCanvas.height = video.videoHeight;
      cropCanvas.width = 320; cropCanvas.height = 120;
      procCanvas.width = 640; procCanvas.height = 240; // after processing (scaled)
    }catch(err){ alert('Kh√¥ng m·ªü ƒë∆∞·ª£c camera: '+err.message); }
  }
  $('#openBtn').addEventListener('click', openCamera);

  // ====== OpenCV init ======
  let cvReady = false; function onOpenCvReady(){ cv['onRuntimeInitialized']=()=>{ cvReady=true; loader.textContent='OpenCV: ready, Templates: ƒëang t·∫£i...'; loadTemplates(); }; }

  // ====== Template Matching OCR ======
  const CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  const templates = {}; // { 'A': cv.Mat, ... }
  let templatesReady = false;

  async function loadTemplates(){
    let loaded = 0;
    for(const c of CHARS){
      try {
        const img = new Image();
        img.src = `templates/${c}.png`;
        await img.decode();
        const canvas = document.createElement('canvas');
        canvas.width = img.width; canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img,0,0);
        let mat = cv.imread(canvas);
        cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY, 0);
        // Chu·∫©n h√≥a: nh·ªã ph√¢n ch·ªØ tr·∫Øng n·ªÅn ƒëen
        cv.threshold(mat, mat, 0, 255, cv.THRESH_BINARY|cv.THRESH_OTSU);
        const mean = cv.mean(mat)[0];
        if(mean < 127){ // n·∫øu ch·ªØ ƒëen n·ªÅn tr·∫Øng -> ƒë·∫£o
          cv.bitwise_not(mat, mat);
        }
        templates[c] = mat; loaded++;
        loader.textContent = `Templates: ${loaded}/36`;
      } catch (e) {
        console.warn('L·ªói t·∫£i template', c, e);
      }
    }
    templatesReady = Object.keys(templates).length >= 10; // √≠t nh·∫•t ph·∫£i c√≥ m·ªôt s·ªë m·∫´u
    loader.textContent = templatesReady ? 'Templates: ready' : 'Templates: thi·∫øu file (h√£y ki·ªÉm tra th∆∞ m·ª•c templates)';
  }

  // So kh·ªõp m·ªôt k√Ω t·ª± (Mat nh·ªã ph√¢n, ch·ªØ tr·∫Øng n·ªÅn ƒëen)
  function matchChar(charMat){
    let bestChar='?', bestScore=-1;
    for(const c of CHARS){
      if(!templates[c]) continue;
      const tpl = templates[c];
      let resized = new cv.Mat();
      cv.resize(charMat, resized, tpl.size(), 0, 0, cv.INTER_AREA);
      let result = new cv.Mat();
      cv.matchTemplate(resized, tpl, result, cv.TM_CCOEFF_NORMED);
      const { maxVal } = cv.minMaxLoc(result);
      if(maxVal > bestScore){ bestScore = maxVal; bestChar = c; }
      result.delete(); resized.delete();
    }
    return bestChar;
  }

  function drawPreviews(cropMat, procMat){
    // crop preview
    const cCanvas = cropPrev; const cCtx=cCanvas.getContext('2d');
    const tmp1 = document.createElement('canvas'); tmp1.width=cropMat.cols; tmp1.height=cropMat.rows;
    cv.imshow(tmp1, cropMat); cCtx.clearRect(0,0,cCanvas.width,cCanvas.height); cCtx.drawImage(tmp1,0,0,cCanvas.width,cCanvas.height);
    // processed preview
    const pCanvas = procPrev; const pCtx=pCanvas.getContext('2d');
    const tmp2 = document.createElement('canvas'); tmp2.width=procMat.cols; tmp2.height=procMat.rows;
    cv.imshow(tmp2, procMat); pCtx.clearRect(0,0,pCanvas.width,pCanvas.height); pCtx.drawImage(tmp2,0,0,pCanvas.width,pCanvas.height);
  }

  function getRoi(){
    const vRect = video.getBoundingClientRect();
    const oRect = overlay.getBoundingClientRect();
    const scaleX = video.videoWidth / vRect.width;
    const scaleY = video.videoHeight / vRect.height;
    const x = Math.max(0, (oRect.left - vRect.left) * scaleX);
    const y = Math.max(0, (oRect.top - vRect.top) * scaleY);
    const w = Math.min(video.videoWidth - x, oRect.width * scaleX);
    const h = Math.min(video.videoHeight - y, oRect.height * scaleY);
    return {x:Math.round(x), y:Math.round(y), w:Math.round(w), h:Math.round(h)};
  }

  // X·ª≠ l√Ω khung h√¨nh: Gray ‚Üí Resize √ó3 ‚Üí Blur ‚Üí Adaptive Threshold ‚Üí Open ‚Üí Unsharp ‚Üí Chu·∫©n h√≥a nh·ªã ph√¢n ch·ªØ tr·∫Øng n·ªÅn ƒëen
  function processFrame(){
    if(!cvReady || video.readyState<2) return null;
    const rctx = rawCanvas.getContext('2d');
    rctx.drawImage(video, 0, 0, rawCanvas.width, rawCanvas.height);
    let src = cv.imread(rawCanvas);

    const {x,y,w,h} = getRoi();
    let roi = src.roi(new cv.Rect(x,y,w,h));

    let gray = new cv.Mat();
    cv.cvtColor(roi, gray, cv.COLOR_RGBA2GRAY, 0);

    let up = new cv.Mat();
    cv.resize(gray, up, new cv.Size(0,0), 3, 3, cv.INTER_CUBIC);

    let blur = new cv.Mat();
    cv.GaussianBlur(up, blur, new cv.Size(3,3), 0);

    let bin = new cv.Mat();
    cv.adaptiveThreshold(blur, bin, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 21, 10);

    // Morph open
    let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(2,2));
    let opened = new cv.Mat();
    cv.morphologyEx(bin, opened, cv.MORPH_OPEN, kernel);

    // Unsharp
    let sharp = new cv.Mat();
    let openedBlur = new cv.Mat();
    cv.GaussianBlur(opened, openedBlur, new cv.Size(0,0), 1.0);
    cv.addWeighted(opened, 1.5, openedBlur, -0.5, 0, sharp);

    // Chu·∫©n h√≥a: ch·ªØ tr·∫Øng n·ªÅn ƒëen
    const mean = cv.mean(sharp)[0];
    let proc = new cv.Mat();
    if(mean < 127){ // n·∫øu n·ªÅn t·ªëi ch·ªØ s√°ng ‚Üí invert ƒë·ªÉ th√†nh ch·ªØ tr·∫Øng n·ªÅn ƒëen
      cv.bitwise_not(sharp, proc);
    } else {
      proc = sharp.clone();
    }

    drawPreviews(roi, proc);
    cv.imshow(procCanvas, proc);

    src.delete(); roi.delete(); gray.delete(); up.delete(); blur.delete(); bin.delete(); opened.delete(); kernel.delete(); openedBlur.delete();
    return proc; // tr·∫£ v·ªÅ Mat (ƒë√£ chu·∫©n h√≥a)
  }

  // Ph√¢n t√°ch k√Ω t·ª± b·∫±ng connected components + l·ªçc k√≠ch th∆∞·ªõc & t·ªâ l·ªá
  function segmentCharacters(procMat){
    let bin = procMat.clone();
    // bin ph·∫£i l√† nh·ªã ph√¢n: ƒë·∫£m b·∫£o threshold l·∫°i b·∫±ng OTSU nh·∫π
    cv.threshold(bin, bin, 0, 255, cv.THRESH_BINARY|cv.THRESH_OTSU);

    // TƒÉng d√£n nh·∫π theo chi·ªÅu d·ªçc ƒë·ªÉ k√Ω t·ª± ƒë·∫≠m h∆°n (t√πy h√¨nh)
    let k = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(1,2));
    cv.morphologyEx(bin, bin, cv.MORPH_CLOSE, k);
    k.delete();

    let labels = new cv.Mat();
    let stats = new cv.Mat();
    let centroids = new cv.Mat();
    const n = cv.connectedComponentsWithStats(bin, labels, stats, centroids);

    const boxes = [];
    for(let i=1;i<n;i++){ // 0 l√† n·ªÅn
      const x = stats.intPtr(i, cv.CC_STAT_LEFT)[0];
      const y = stats.intPtr(i, cv.CC_STAT_TOP)[0];
      const w = stats.intPtr(i, cv.CC_STAT_WIDTH)[0];
      const h = stats.intPtr(i, cv.CC_STAT_HEIGHT)[0];
      const area = stats.intPtr(i, cv.CC_STAT_AREA)[0];
      // L·ªçc theo di·ªán t√≠ch v√† t·ªâ l·ªá h·ª£p l√Ω v·ªõi ch·ªØ in
      if(area < 60) continue;
      const ar = w / h;
      if(ar < 0.2 || ar > 2.0) continue;
      boxes.push({x,y,w,h});
    }

    // Gom nh√≥m theo h√†ng ngang (trong ROI coi nh∆∞ 1 h√†ng)
    boxes.sort((a,b)=> a.x - b.x);

    labels.delete(); stats.delete(); centroids.delete(); bin.delete();
    return boxes;
  }

  // Nh·∫≠n d·∫°ng chu·ªói theo th·ª© t·ª± tr√°i‚Üíph·∫£i, ch√®n kho·∫£ng tr·∫Øng sau 6 k√Ω t·ª±
  function recognizeText(procMat){
    const boxes = segmentCharacters(procMat);
    let text = '';
    for(const r of boxes){
      const roi = procMat.roi(new cv.Rect(r.x, r.y, r.w, r.h));
      const ch = matchChar(roi);
      text += ch;
      roi.delete();
    }
    if(text.length >= 6) text = text.slice(0,6) + ' ' + text.slice(6);

    // Chu·∫©n h√≥a: ch·ªâ gi·ªØ 0-9 A-Z, upper
    text = text.replace(/\s+/g,' ').trim().toUpperCase();
    text = text.replace(/[^0-9A-Z ]/g,'');
    return text;
  }

  // ====== OCR triggers ======
  async function captureOnce(){
    if(!templatesReady){ alert('Templates ch∆∞a s·∫µn s√†ng (thi·∫øu file trong /templates)'); return; }
    const procMat = processFrame();
    if(!procMat) return;
    const cleaned = recognizeText(procMat);
    ocrTextDiv.textContent = cleaned;

    const targets = $('#dateList').value.split('\n').map(v=>v.trim()).filter(Boolean);
    const matched = targets.includes(cleaned);
    resultDiv.textContent = matched ? '‚úÖ ƒê√öNG' : '‚ùå SAI';
    resultDiv.className = 'status ' + (matched ? 'ok' : 'fail');

    // G·ª£i √Ω ƒë·ªãnh d·∫°ng n·∫øu sai
    const pat = /^\d{6}\s[0-9A-Z]{5}$/;
    if(!matched){
      if(pat.test(cleaned)){
        resultDiv.textContent += ' (format h·ª£p l·ªá, kh√¥ng kh·ªõp danh s√°ch)';
      } else {
        resultDiv.textContent += ' (kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng 6 s·ªë + kho·∫£ng tr·∫Øng + 5 k√Ω t·ª±)';
      }
    }

    procMat.delete();
  }
  $('#captureBtn').addEventListener('click', captureOnce);

  // Auto scan loop (m·∫∑c ƒë·ªãnh 450ms gi·ªØ nguy√™n)
  $('#toggleAuto').addEventListener('click', async function(){
    autoScan = !autoScan; this.textContent = 'Auto Scan: ' + (autoScan? 'ON':'OFF');
    if(autoScan){
      const loop = async()=>{
        if(!autoScan) return;
        if(templatesReady){
          const procMat = processFrame();
          if(procMat){
            const cleaned = recognizeText(procMat);
            ocrTextDiv.textContent = cleaned;
            const targets = $('#dateList').value.split('\n').map(v=>v.trim()).filter(Boolean);
            const matched = targets.includes(cleaned);
            resultDiv.textContent = matched ? '‚úÖ ƒê√öNG' : '‚ùå SAI';
            resultDiv.className = 'status ' + (matched ? 'ok' : 'fail');
            procMat.delete();
          }
        }
        autoTimer = setTimeout(loop, 450);
      };
      loop();
    } else { if(autoTimer) clearTimeout(autoTimer); }
  });
</script>
</body>
</html>
