<!-- /index.html -->
<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
<title>OCR Date Checker Vinasoy (NƒêT)</title>
<style>
:root{ --w: 340px; --h: 240px; }
body{ font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#f6f7f9; margin:0; }
.wrap{ max-width:720px; margin:0 auto; padding:14px; }
h1{ font-size:20px; margin:10px 0; }
.row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
label{ font-size:14px; color:#333; }
input, select, button, textarea{ font-size:14px; padding:10px; border-radius:10px; border:1px solid #dfe3ea; background:#fff; }
button{ cursor:pointer; border:none; background:#0a7cff; color:#fff; box-shadow:0 4px 12px rgba(10,124,255,.2); }
button:active{ transform:translateY(1px); }
textarea{ width:100%; min-height:120px; }
.camera{ position:relative; display:inline-block; }
video{ width:var(--w); height:var(--h); object-fit:cover; border-radius:12px; border:2px solid #e3e7ee; background:#000; }
#crossOverlay{ position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; display:block; }
.mini{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:8px 0; }
.status{ font-weight:700; font-size:16px; }
.ok{ color:#1f9d55; } .fail{ color:#e11d48; } .muted{ color:#6b7280; font-weight:500; }
/* th√™m m√†u c·∫£nh b√°o cho batch l·ªách */
.warn{ color:#d97706; }
canvas{ display:none; }
.preview{ display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap; margin-top:8px; }
@@ -57,7 +56,6 @@

<div class="mini">
  <button id="openBtn">B·∫≠t camera</button>
  
  <button id="toggleAuto">Auto Scan: OFF</button>
  <span id="loader" class="muted">Templates: ch∆∞a t·∫£i</span>
</div>
@@ -67,7 +65,6 @@
  <canvas id="crossOverlay"></canvas>
</div>

<!-- C·ª•m Ch·ª•p + K·∫øt qu·∫£ -->
<div class="mini">
  <button id="captureBtn">üì∑ Ch·ª•p & OCR</button>
  <span id="result" class="status muted">‚Äî</span>
@@ -181,41 +178,42 @@
    $('#loader').textContent='OpenCV: ready';
  };
}

function getRoiFromPlusSign(){
  const centerX = video.videoWidth / 2;
  const centerY = video.videoHeight / 2;
  const roiWidth = 240;  
  const roiHeight = 84;  
  const x = Math.max(0, centerX - roiWidth / 2);
  const y = Math.max(0, centerY - roiHeight / 2);
  return {x:Math.round(x), y:Math.round(y), w:roiWidth, h:roiHeight};
}

/* ======= Image Processing (t·ªëi ∆∞u ƒë·ªô n√©t) ======= */
/* ======= Image Processing (t·ªëi ∆∞u ƒë·ªô n√©t & l√†m s·∫°ch n·ªÅn) ======= */
function processFrame(){
  if(!cvReady || video.readyState<2) return null;
  const rctx = rawCanvas.getContext('2d');
  rctx.drawImage(video, 0, 0, rawCanvas.width, rawCanvas.height);

  let src = cv.imread(rawCanvas);
  const {x,y,w,h} = getRoiFromPlusSign();
  let roi = src.roi(new cv.Rect(x,y,w,h));

  // Chuy·ªÉn grayscale
  let gray = new cv.Mat();
  cv.cvtColor(roi, gray, cv.COLOR_RGBA2GRAY, 0);

  // CLAHE: tƒÉng t∆∞∆°ng ph·∫£n c·ª•c b·ªô (why: n·ªÅn carton, m·ª±c m·ªù)
  // CLAHE: tƒÉng t∆∞∆°ng ph·∫£n c·ª•c b·ªô
  let claheMat = new cv.Mat();
  try {
    const clahe = new cv.CLAHE(2.0, new cv.Size(8,8));
    clahe.apply(gray, claheMat);
    clahe.delete && clahe.delete();
  } catch(e){
    claheMat = gray.clone(); // fallback n·∫øu build OpenCV thi·∫øu CLAHE
    claheMat = gray.clone();
  }

  // Unsharp mask: n√©t ƒë·∫≠m h∆°n
  // Unsharp mask: l√†m n√©t ch·ªØ
  let gauss = new cv.Mat(), sharp = new cv.Mat();
  cv.GaussianBlur(claheMat, gauss, new cv.Size(0,0), 1.0);
  cv.addWeighted(claheMat, 1.5, gauss, -0.5, 0, sharp);
@@ -224,295 +222,293 @@
  let up = new cv.Mat();
  cv.resize(sharp, up, new cv.Size(sharp.cols*3, sharp.rows*3), 0, 0, cv.INTER_CUBIC);

  // Threshold OTSU (·ªïn ƒë·ªãnh h∆°n adaptive khi n·ªÅn ƒë·ªÅu)
  // L√†m m∆∞·ª£t n·ªÅn
  cv.GaussianBlur(up, up, new cv.Size(3,3), 0);

  // Adaptive threshold ƒë·ªÉ b·ªè n·ªÅn carton
  let bin = new cv.Mat();
  cv.threshold(up, bin, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);
  cv.adaptiveThreshold(up, bin, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 35, 15);

  // ƒê·∫£m b·∫£o ch·ªØ ƒëen n·ªÅn tr·∫Øng
  let mean = cv.mean(bin)[0];
  let bw = new cv.Mat();
  if(mean > 127){
    bw = bin.clone();
  } else {
    cv.bitwise_not(bin, bw);
  }
  if(mean < 127) cv.bitwise_not(bin, bin);

  // Close ƒë·ªÉ li·ªÅn n√©t + l·ªçc nhi·ªÖu nh·ªè
  let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3,3));
  let closed = new cv.Mat();
  cv.morphologyEx(bw, closed, cv.MORPH_CLOSE, kernel);
  // Morphology open: lo·∫°i nhi·ªÖu nh·ªè
  let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(2,2));
  let cleaned = new cv.Mat();
  cv.morphologyEx(bin, cleaned, cv.MORPH_OPEN, kernel);

  // Padding vi·ªÅn
  // Padding vi·ªÅn tr·∫Øng
  let bordered = new cv.Mat();
  cv.copyMakeBorder(closed, bordered, 10,10,10,10, cv.BORDER_CONSTANT, new cv.Scalar(255,255,255,255));
  cv.copyMakeBorder(cleaned, bordered, 10,10,10,10, cv.BORDER_CONSTANT, new cv.Scalar(255,255,255,255));

  // Preview
  cv.imshow($('#cropPreview'), roi);
  cv.imshow($('#procPreview'), bordered);

  // Cleanup
  src.delete(); roi.delete(); gray.delete(); claheMat.delete(); gauss.delete(); sharp.delete(); up.delete();
  bin.delete(); bw.delete(); kernel.delete(); closed.delete();
  bin.delete(); kernel.delete(); cleaned.delete();

  return bordered; // caller ph·∫£i .delete()
}

/* ======= Tesseract Worker ======= */
async function ensureWorker(){
  if(workerReady) return;
  $('#loader').textContent='Tesseract: loading...';
  worker = await Tesseract.createWorker();
  await worker.loadLanguage('eng');
  await worker.initialize('eng');
  await worker.setParameters({
    tessedit_char_whitelist: '0123456789ABCDEFGHI ',
    tessedit_pageseg_mode: '7',            // single line
    preserve_interword_spaces: '1',
    user_defined_dpi: '300'
  });
  workerReady = true;
  $('#loader').textContent='OpenCV: ready ¬∑ Tesseract: ready';
}

/* ======= Fuzzy match c√≥ tr·ªçng s·ªë ======= */
function charSubCost(a,b,pos){
  if(a===b) return 0;
  const pair = a+b, pairR = b+a;
  const soft = new Set(['0O','O0','5S','S5','8B','B8','90','09']);
  if(soft.has(pair) || soft.has(pairR)) return 0.4;
  if(pos===10 && ((a==='G'&&b==='A')||(a==='A'&&b==='G'))) return 0.5; // v·ªã tr√≠ ch·ªØ
  return 1;
}
function weightedEditDistance(a,b){
  const n=a.length, m=b.length;
  const dp = Array.from({length:n+1}, ()=>Array(m+1).fill(0));
  for(let i=0;i<=n;i++) dp[i][0]=i;
  for(let j=0;j<=m;j++) dp[0][j]=j;
  for(let i=1;i<=n;i++){
    for(let j=1;j<=m;j++){
      const cost = charSubCost(a[i-1], b[j-1], j-1);
      dp[i][j] = Math.min(
        dp[i-1][j] + 1,      // delete
        dp[i][j-1] + 1,      // insert
        dp[i-1][j-1] + cost  // substitute
      );
    }
  }
  return dp[n][m];
}
function bestFuzzy(targets, text){
  let best=null, bestScore=1e9;
  for(const t of targets){
    const s = weightedEditDistance(text, t);
    if(s < bestScore){ bestScore=s; best=t; }
  }
  return {best, dist: bestScore};
}

/* ======= Post-process d·∫°ng c·ª©ng theo pattern ======= */
function postProcess(text){
  // Chu·∫©n ho√°
  let cleaned = text.replace(/\s+/g,' ').trim().toUpperCase();
  cleaned = cleaned.replace(/[^0-9A-I ]/g,'');
  // Pattern ƒë√≠ch: d{6} sp d{3} [A-I] [1-7]
  const regex = /^\d{6} \d{3}[A-I][1-7]$/;
  if(regex.test(cleaned)) return cleaned;

  // S·ª≠a l·ªói theo v·ªã tr√≠ (why: gi·∫£m 9‚Üí0, G‚ÜíA)
  const chars = cleaned.padEnd(12, ' ').split('');
  // 0..5
  for(let i=0;i<=5;i++) if(!/[0-9]/.test(chars[i])) chars[i]='0';
  // 6 = space
  chars[6] = ' ';
  // 7..9
  for(let i=7;i<=9;i++){
    if(/[OSB]/.test(chars[i])) chars[i] = ({'O':'0','S':'5','B':'8'})[chars[i]];
    if(!/[0-9]/.test(chars[i])) chars[i]='0';
  }
  // 10 = letter
  if(!/[A-I]/.test(chars[10])) chars[10]='A';
  // 11 = weekday
  if(!/[1-7]/.test(chars[11])) chars[11]='1';

  const fixed = chars.join('').slice(0,12);
  return regex.test(fixed) ? fixed: cleaned;
}

/* ======= ∆Øu ti√™n tuy·ªát ƒë·ªëi ddMMyy ======= */
/* why: ƒë·∫£m b·∫£o quy·∫øt ƒë·ªãnh d·ª±a tr√™n HSD tr∆∞·ªõc, tr√°nh fuzzy g√¢y nh·∫ßm */
function getDatePart(code){
  if(!code) return '';
  return code.replace(/\s+/g,'').slice(0,6); // ddMMyy
}
function getExpectedDate(targets){
  const first = targets.find(Boolean);
  return first ? getDatePart(first) : '';
}
/**
 * ƒê√°nh gi√° quy·∫øt ƒë·ªãnh theo rule:
 * - date kh√°c -> SAI
 * - date ƒë√∫ng & full tr√πng -> ƒê√öNG
 * - date ƒë√∫ng & full KH√ÅC -> C·∫¢NH B√ÅO (ƒë√∫ng HSD, l·ªách batch)
 */
function evaluateDecision(cleaned, targets){
  const expectedDate = getExpectedDate(targets);
  const gotDate = getDatePart(cleaned);
  if(!expectedDate || gotDate.length<6 || !/^\d{6}$/.test(gotDate)){
    return { verdict:'date_mismatch', expectedDate, gotDate };
  }
  if(gotDate !== expectedDate){
    return { verdict:'date_mismatch', expectedDate, gotDate };
  }
  const exact = targets.includes(cleaned);
  if(exact){
    return { verdict:'exact', expectedDate, gotDate };
  }
  return { verdict:'date_match_batch_diff', expectedDate, gotDate };
}

/* ======= √Çm thanh b√°o hi·ªáu (ƒë√∫ng/sai) ======= */
function playSound(matched){
  const el = matched ? $('#soundCorrect') : $('#soundWrong');
  const src = el.currentSrc || el.querySelector('source')?.src;
  if(!src) return;
  const vol = 1.0; // why: c·∫ßn l·ªõn d·ªÖ nghe trong m√¥i tr∆∞·ªùng ·ªìn
  const playOnce = () => { const a = new Audio(src); a.volume = vol; a.play().catch(()=>{}); };
  playOnce();
  setTimeout(playOnce, 140);
}

/* ======= OCR ======= */
async function runTesseract(procMat){
  await ensureWorker();
  const tmpCanvas = document.createElement('canvas');
  tmpCanvas.width = procMat.cols; 
  tmpCanvas.height = procMat.rows;
  cv.imshow(tmpCanvas, procMat);

  const { data: { text } } = await worker.recognize(tmpCanvas);
  tmpCanvas.width = tmpCanvas.height = 0;
  tmpCanvas.remove();
  return postProcess(text);
}

/* ======= Capture ======= */
async function captureOnce(){
  if(ocrBusy) return;
  const procMat = processFrame();
  if(!procMat) return;
  ocrBusy = true;
  try{
    const cleaned = await runTesseract(procMat);
    const targets = $('#dateList').value.split('\n').map(v=>v.trim()).filter(Boolean);

    // fuzzy ch·ªâ ƒë·ªÉ tham kh·∫£o hi·ªÉn th·ªã
    const {best, dist} = bestFuzzy(targets, cleaned);

    // Quy·∫øt ƒë·ªãnh theo ∆∞u ti√™n ddMMyy
    const decision = evaluateDecision(cleaned, targets);

    // UI hi·ªÉn th·ªã: th√™m date got/expected ƒë·ªÉ r√µ r√†ng
    const info = best 
      ? `${cleaned}  ‚âà  ${best}  (score ${dist.toFixed(2)})`
      : cleaned;
    ocrTextDiv.textContent = `[got:${decision.gotDate||'‚Äî'} vs exp:${decision.expectedDate||'‚Äî'}]  ${info}`;

    if(decision.verdict === 'exact'){
      resultDiv.textContent = '‚úÖ ƒê√öNG';
      resultDiv.className = 'status ok';
    } else if(decision.verdict === 'date_match_batch_diff'){
      resultDiv.textContent = '‚ö†Ô∏è ƒê√öNG HSD, L·ªÜCH BATCH';
      resultDiv.className = 'status warn';
    } else {
      resultDiv.textContent = '‚ùå SAI';
      resultDiv.className = 'status fail';
    }

    playSound(decision.verdict === 'exact');
    if (decision.verdict === 'exact' && "vibrate" in navigator) navigator.vibrate(200);
  } finally {
    procMat.delete();
    ocrBusy = false;
  }
}
$('#captureBtn').addEventListener('click', captureOnce);

/* ======= Auto Scan (ch·ªëng ch·∫°y ch·ªìng) ======= */
$('#toggleAuto').addEventListener('click', async function(){
  autoScan = !autoScan; this.textContent = 'Auto Scan: ' + (autoScan? 'ON':'OFF');
  if(autoScan){
    const loop = async()=>{
      if(!autoScan) return;
      if(!ocrBusy){
        const procMat = processFrame();
        if(procMat){
          ocrBusy = true;
          try{
            const cleaned = await runTesseract(procMat);
            const targets = $('#dateList').value.split('\n').map(v=>v.trim()).filter(Boolean);

            const {best, dist} = bestFuzzy(targets, cleaned);
            const decision = evaluateDecision(cleaned, targets);

            const info = best 
              ? `${cleaned}  ‚âà  ${best}  (score ${dist.toFixed(2)})`
              : cleaned;
            ocrTextDiv.textContent = `[got:${decision.gotDate||'‚Äî'} vs exp:${decision.expectedDate||'‚Äî'}]  ${info}`;

            if(decision.verdict === 'exact'){
              resultDiv.textContent = '‚úÖ ƒê√öNG';
              resultDiv.className = 'status ok';
            } else if(decision.verdict === 'date_match_batch_diff'){
              resultDiv.textContent = '‚ö†Ô∏è ƒê√öNG HSD, L·ªÜCH BATCH';
              resultDiv.className = 'status warn';
            } else {
              resultDiv.textContent = '‚ùå SAI';
              resultDiv.className = 'status fail';
            }

            playSound(decision.verdict === 'exact');

            // ch·ªâ d·ª´ng Auto khi ƒê√öNG ho√†n to√†n
            if (decision.verdict === 'exact'){
              if ("vibrate" in navigator) navigator.vibrate(200);
              autoScan = false;
              $('#toggleAuto').textContent = 'Auto Scan: OFF';
            }
          } finally {
            procMat.delete();
            ocrBusy = false;
          }
        }
      }
      if(autoScan) autoTimer = setTimeout(loop, 500);
    };
    loop();
  } else { if(autoTimer) clearTimeout(autoTimer); }
});
// Unlock audio cho iPhone
function unlockAudio() {
  const correct = document.getElementById("soundCorrect");
  const wrong = document.getElementById("soundWrong");
  correct.volume = 1.0;
  wrong.volume = 1.0;
  correct.currentTime = 0;
  correct.play().catch(()=>{});
  wrong.currentTime = 0;
  wrong.play().catch(()=>{});
  document.removeEventListener("touchstart", unlockAudio);
  document.removeEventListener("click", unlockAudio);
}
document.addEventListener("touchstart", unlockAudio);
document.addEventListener("click", unlockAudio);
</script>

<!-- √Çm thanh b√°o hi·ªáu -->
<audio id="soundCorrect" preload="auto">
  <source src="https://actions.google.com/sounds/v1/alarms/beep_short.mp3" type="audio/mp3">
</audio>
<audio id="soundWrong" preload="auto">
  <source src="https://actions.google.com/sounds/v1/alarms/beep_buzzer.mp3" type="audio/mp3">
</audio>

</body>
</html>
