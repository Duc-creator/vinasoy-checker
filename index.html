<!-- /index.html -->
<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
  <title>OCR Date Checker Vinasoy (NƒêT)</title>
  <style>
    :root{ --w: 340px; --h: 240px; }
    body{ font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#f6f7f9; margin:0; }
    .wrap{ max-width:720px; margin:0 auto; padding:14px; }
    h1{ font-size:20px; margin:10px 0; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    label{ font-size:14px; color:#333; }
    input, select, button, textarea{ font-size:14px; padding:10px; border-radius:10px; border:1px solid #dfe3ea; background:#fff; }
    button{ cursor:pointer; border:none; background:#0a7cff; color:#fff; box-shadow:0 4px 12px rgba(10,124,255,.2); }
    button:active{ transform:translateY(1px); }
    textarea{ width:100%; min-height:120px; }
    .camera{ position:relative; display:inline-block; }
    video{ width:var(--w); height:var(--h); object-fit:cover; border-radius:12px; border:2px solid #e3e7ee; background:#000; }
    #crossOverlay{ position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; display:block; }
    .mini{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:8px 0; }
    .status{ font-weight:700; font-size:16px; }
    .ok{ color:#1f9d55; }
    .fail{ color:#e11d48; }
    .muted{ color:#6b7280; font-weight:500; }
    .warn{ color:#d97706; }
    canvas{ display:none; }
    .preview{ display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap; margin-top:8px; }
    .box{ background:#fff; border:1px solid #e5e7eb; border-radius:10px; padding:8px; }
    .box h3{ margin:0 0 6px 0; font-size:13px; color:#374151; }
    .box canvas{ display:block; width:220px; height:auto; border-radius:8px; }
    .tip{ font-size:12px; color:#6b7280; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>OCR Date Checker Vinasoy (NƒêT)</h1>

    <div class="row">
      <label>H·∫°n d√πng (th√°ng)
        <select id="shelfLife">
          <option value="6">6</option>
          <option value="9">9</option>
          <option value="10">10</option>
        </select>
      </label>

      <label>M√£ l√¥ (3 k√Ω t·ª±)
        <input id="batchCode" maxlength="3" placeholder="VD: 086" />
      </label>

      <label>Th·ª© h√¥m nay
        <input id="weekday" readonly style="width:60px" />
      </label>

      <label class="mini">
        <input type="checkbox" id="singleLineCheck" /> Ch·ªâ 1 line
      </label>

      <label id="lineSelectWrapper" style="display:none;">Line
        <select id="lineSelect">
          <option>A</option><option>B</option><option>C</option>
          <option>D</option><option>E</option><option>F</option>
          <option>G</option><option>H</option><option>I</option>
        </select>
      </label>

      <button id="generateBtn">T·∫°o danh s√°ch date</button>
    </div>

    <textarea id="dateList" placeholder="Danh s√°ch date code..."></textarea>

    <div class="mini">
      <button id="openBtn">B·∫≠t camera</button>
      <button id="toggleAuto">Auto Scan: OFF</button>
      <span id="loader" class="muted">OpenCV/Tesseract: ch∆∞a t·∫£i</span>
    </div>

    <div class="camera">
      <video id="video" playsinline muted></video>
      <canvas id="crossOverlay"></canvas>
    </div>

    <div class="mini">
      <button id="captureBtn">üì∑ Ch·ª•p & OCR</button>
      <span id="result" class="status muted">‚Äî</span>
    </div>

    <div id="ocrText" class="tip"></div>

    <canvas id="rawCanvas"></canvas>
    <canvas id="cropCanvas"></canvas>
    <canvas id="procCanvas"></canvas>

    <div class="preview">
      <div class="box"><h3>Crop</h3><canvas id="cropPreview" width="220" height="100"></canvas></div>
      <div class="box"><h3>Processed</h3><canvas id="procPreview" width="220" height="100"></canvas></div>
    </div>

    <p class="tip">M·∫πo: ƒê·∫∑t ƒë·ªëi t∆∞·ª£ng ngay t·∫°i d·∫•u c·ªông ƒë·ªÉ OCR nhanh v√† ch√≠nh x√°c.</p>
  </div>

  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
  <script>
    /* ======= DOM & STATE ======= */
    const $ = (s) => document.querySelector(s);
    const video = $('#video');
    const crossOverlay = $('#crossOverlay');
    const resultDiv = $('#result');
    const ocrTextDiv = $('#ocrText');
    const rawCanvas = $('#rawCanvas');

    let autoScan = false, autoTimer = null;
    let cvReady = false;
    let ocrBusy = false;

    // Tesseract worker
    let worker = null;
    let workerReady = false;

    /* ======= UI ======= */
    function drawCross(){
      const ctx = crossOverlay.getContext('2d');
      ctx.clearRect(0,0,crossOverlay.width,crossOverlay.height);
      ctx.strokeStyle = 'rgba(255,0,0,0.95)';
      ctx.lineWidth = 3;
      const centerX = crossOverlay.width / 2;
      const centerY = crossOverlay.height / 2;
      const vLen = 50, hLen = 50;

      ctx.beginPath();
      ctx.moveTo(centerX - hLen/2, centerY);
      ctx.lineTo(centerX + hLen/2, centerY);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(centerX, centerY - vLen/2);
      ctx.lineTo(centerX, centerY + vLen/2);
      ctx.stroke();
    }

    window.addEventListener('resize', ()=>{
      crossOverlay.width = video.clientWidth;
      crossOverlay.height = video.clientHeight;
      drawCross();
    });

    function updateWeekday(){
      const d=new Date();
      const day=d.getDay(); // 0=CN..6=Th7
      const weekday=(day===0)?1:day+1; // CN=1, Th2=2..Th7=7
      $('#weekday').value=weekday;
    }
    updateWeekday();

    function addMonthsAdjust(date, months){
      const y=date.getFullYear();
      const m=date.getMonth();
      const day=date.getDate();
      const nm=m+months;
      const nd=new Date(y, nm, 1);
      const last=new Date(nd.getFullYear(), nd.getMonth()+1, 0).getDate();
      return new Date(nd.getFullYear(), nd.getMonth(), Math.min(day,last));
    }

    $('#generateBtn').addEventListener('click', ()=>{
      const batchCode = $('#batchCode').value.trim();
      const weekday = $('#weekday').value;
      const shelfMonths = parseInt($('#shelfLife').value, 10);
      const singleLine = $('#singleLineCheck').checked;
      const line = $('#lineSelect').value;

      if(batchCode.length!==3){
        alert('Nh·∫≠p m√£ l√¥ 3 k√Ω t·ª±');
        return;
      }

      const expiry = addMonthsAdjust(new Date(), shelfMonths);
      const dd=String(expiry.getDate()).padStart(2,'0');
      const mm=String(expiry.getMonth()+1).padStart(2,'0');
      const yy=String(expiry.getFullYear()).slice(2);
      const dateCode = dd+mm+yy;

      let res='';
      if(singleLine){
        res = `${dateCode} ${batchCode}${line}${weekday}`;
      } else{
        ['A','B','C','D','E','F','G','H','I'].forEach(L=>{
          res += `${dateCode} ${batchCode}${L}${weekday}\n`;
        });
        res=res.trim();
      }
      $('#dateList').value = res;
    });

    $('#singleLineCheck').addEventListener('change', function(){
      $('#lineSelectWrapper').style.display = this.checked? 'inline-block':'none';
    });

    /* ======= Camera & OpenCV ======= */
    async function openCamera(){
      try{
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: 'environment' } },
          audio:false
        });
        video.srcObject = stream;
        await video.play();

        crossOverlay.width = video.clientWidth;
        crossOverlay.height = video.clientHeight;
        rawCanvas.width = video.videoWidth;
        rawCanvas.height = video.videoHeight;

        drawCross();
      }catch(err){
        alert('Kh√¥ng m·ªü ƒë∆∞·ª£c camera: '+err.message);
      }
    }
    $('#openBtn').addEventListener('click', openCamera);

    function onOpenCvReady(){
      if (!window.cv) return;
      cv['onRuntimeInitialized']=()=>{
        cvReady=true;
        $('#loader').textContent='OpenCV: ready';
      };
    }

    function getRoiFromPlusSign(){
      const centerX = video.videoWidth / 2;
      const centerY = video.videoHeight / 2;
      const roiWidth = 240;
      const roiHeight = 84;
      const x = Math.max(0, centerX - roiWidth / 2);
      const y = Math.max(0, centerY - roiHeight / 2);
      return {x:Math.round(x), y:Math.round(y), w:roiWidth, h:roiHeight};
    }

    /* ======= Image Processing ======= */
    function processFrame(){
      if(!cvReady || video.readyState<2) return null;

      const rctx = rawCanvas.getContext('2d');
      rctx.drawImage(video, 0, 0, rawCanvas.width, rawCanvas.height);

      let src = cv.imread(rawCanvas);
      const {x,y,w,h} = getRoiFromPlusSign();
      let roi = src.roi(new cv.Rect(x,y,w,h));

      let gray = new cv.Mat();
      cv.cvtColor(roi, gray, cv.COLOR_RGBA2GRAY, 0);

      // CLAHE (why: m·ª±c nh·∫°t, n·ªÅn carton kh√¥ng ƒë·ªÅu)
      let claheMat = new cv.Mat();
      try {
        const clahe = cv.createCLAHE(2.0, new cv.Size(8,8)); // API ph·ªï bi·∫øn c·ªßa OpenCV.js
        clahe.apply(gray, claheMat);
        clahe.delete && clahe.delete();
      } catch(e){
        claheMat = gray.clone(); // fallback n·∫øu build thi·∫øu CLAHE
      }

      // Unsharp mask
      let gauss = new cv.Mat(), sharp = new cv.Mat();
      cv.GaussianBlur(claheMat, gauss, new cv.Size(0,0), 1.0);
      cv.addWeighted(claheMat, 1.5, gauss, -0.5, 0, sharp);

      // Upscale x3
      let up = new cv.Mat();
      cv.resize(sharp, up, new cv.Size(sharp.cols*3, sharp.rows*3), 0, 0, cv.INTER_CUBIC);

      // OTSU
      let bin = new cv.Mat();
      cv.threshold(up, bin, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);

      // N·ªÅn tr·∫Øng, ch·ªØ ƒëen
      let mean = cv.mean(bin)[0];
      let bw = new cv.Mat();
      if(mean > 127){ bw = bin.clone(); } else { cv.bitwise_not(bin, bw); }

      // Close
      let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3,3));
      let closed = new cv.Mat();
      cv.morphologyEx(bw, closed, cv.MORPH_CLOSE, kernel);

      // Padding
      let bordered = new cv.Mat();
      cv.copyMakeBorder(closed, bordered, 10,10,10,10, cv.BORDER_CONSTANT, new cv.Scalar(255,255,255,255));

      // Preview
      cv.imshow($('#cropPreview'), roi);
      cv.imshow($('#procPreview'), bordered);

      // Cleanup
      src.delete(); roi.delete(); gray.delete();
      claheMat.delete(); gauss.delete(); sharp.delete();
      up.delete(); bin.delete(); bw.delete(); kernel.delete(); closed.delete();

      return bordered; // caller must delete
    }

    /* ======= Tesseract Worker ======= */
    async function ensureWorker(){
      if(workerReady) return;
      $('#loader').textContent='Tesseract: loading...';
      worker = await Tesseract.createWorker();
      await worker.loadLanguage('eng');
      await worker.initialize('eng');
      await worker.setParameters({
        tessedit_char_whitelist: '0123456789ABCDEFGHI ',
        tessedit_pageseg_mode: '7',
        preserve_interword_spaces: '1',
        user_defined_dpi: '300'
      });
      workerReady = true;
      $('#loader').textContent='OpenCV: ready ¬∑ Tesseract: ready';
    }

    /* ======= Fuzzy match ======= */
    function charSubCost(a,b,pos){
      if(a===b) return 0;
      const pair = a+b, pairR = b+a;
      const soft = new Set(['0O','O0','5S','S5','8B','B8','90','09']);
      if(soft.has(pair) || soft.has(pairR)) return 0.4;
      if(pos===10 && ((a==='G'&&b==='A')||(a==='A'&&b==='G'))) return 0.5;
      return 1;
    }
    function weightedEditDistance(a,b){
      const n=a.length, m=b.length;
      const dp = Array.from({length:n+1}, ()=>Array(m+1).fill(0));
      for(let i=0;i<=n;i++) dp[i][0]=i;
      for(let j=0;j<=m;j++) dp[0][j]=j;
      for(let i=1;i<=n;i++){
        for(let j=1;j<=m;j++){
          const cost = charSubCost(a[i-1], b[j-1], j-1);
          dp[i][j] = Math.min(
            dp[i-1][j] + 1,      // delete
            dp[i][j-1] + 1,      // insert
            dp[i-1][j-1] + cost  // substitute
          );
        }
      }
      return dp[n][m];
    }
    function bestFuzzy(targets, text){
      let best=null, bestScore=1e9;
      for(const t of targets){
        const s = weightedEditDistance(text, t);
        if(s < bestScore){ bestScore=s; best=t; }
      }
      return {best, dist: bestScore};
    }

    /* ======= Post-process theo pattern ======= */
    function postProcess(text){
      let cleaned = text.replace(/\s+/g,' ').trim().toUpperCase();
      cleaned = cleaned.replace(/[^0-9A-I ]/g,'');
      const regex = /^\d{6} \d{3}[A-I][1-7]$/;
      if(regex.test(cleaned)) return cleaned;

      const chars = cleaned.padEnd(12, ' ').split('');
      for(let i=0;i<=5;i++) if(!/[0-9]/.test(chars[i])) chars[i]='0';
      chars[6] = ' ';
      for(let i=7;i<=9;i++){
        if(/[OSB]/.test(chars[i])) chars[i] = ({'O':'0','S':'5','B':'8'})[chars[i]];
        if(!/[0-9]/.test(chars[i])) chars[i]='0';
      }
      if(!/[A-I]/.test(chars[10])) chars[10]='A';
      if(!/[1-7]/.test(chars[11])) chars[11]='1';

      const fixed = chars.join('').slice(0,12);
      return regex.test(fixed) ? fixed: cleaned;
    }

    /* ======= ∆Øu ti√™n ddMMyy ======= */
    function getDatePart(code){
      if(!code) return '';
      return code.replace(/\s+/g,'').slice(0,6);
    }
    function getExpectedDate(targets){
      const first = targets.find(Boolean);
      return first ? getDatePart(first) : '';
    }
    function evaluateDecision(cleaned, targets){
      const expectedDate = getExpectedDate(targets);
      const gotDate = getDatePart(cleaned);
      if(!expectedDate || gotDate.length<6 || !/^\d{6}$/.test(gotDate)){
        return { verdict:'date_mismatch', expectedDate, gotDate };
      }
      if(gotDate !== expectedDate){
        return { verdict:'date_mismatch', expectedDate, gotDate };
      }
      const exact = targets.includes(cleaned);
      if(exact){
        return { verdict:'exact', expectedDate, gotDate };
      }
      return { verdict:'date_match_batch_diff', expectedDate, gotDate };
    }

    /* ======= √Çm thanh ======= */
    function playSound(matched){
      const el = matched ? $('#soundCorrect') : $('#soundWrong');
      const src = el.currentSrc || el.querySelector('source')?.src;
      if(!src) return;

      const vol = 1.0; // why: m√¥i tr∆∞·ªùng ·ªìn
      const playOnce = () => {
        const a = new Audio(src);
        a.volume = vol;
        a.play().catch(()=>{});
      };
      playOnce();
      setTimeout(playOnce, 140);
    }

    /* ======= OCR ======= */
    async function runTesseract(procMat){
      await ensureWorker();
      const tmpCanvas = document.createElement('canvas');
      tmpCanvas.width = procMat.cols;
      tmpCanvas.height = procMat.rows;
      cv.imshow(tmpCanvas, procMat);
      const { data: { text } } = await worker.recognize(tmpCanvas);
      tmpCanvas.width = tmpCanvas.height = 0;
      tmpCanvas.remove();
      return postProcess(text);
    }

    /* ======= Capture ======= */
    async function captureOnce(){
      if(ocrBusy) return;
      const procMat = processFrame();
      if(!procMat) return;

      ocrBusy = true;
      try{
        const cleaned = await runTesseract(procMat);
        const targets = $('#dateList').value.split('\n').map(v=>v.trim()).filter(Boolean);

        const {best, dist} = bestFuzzy(targets, cleaned);
        const decision = evaluateDecision(cleaned, targets);

        const info = best ? `${cleaned} ‚âà ${best} (score ${dist.toFixed(2)})` : cleaned;
        ocrTextDiv.textContent = `[got:${decision.gotDate||'‚Äî'} vs exp:${decision.expectedDate||'‚Äî'}] ${info}`;

        if(decision.verdict === 'exact'){
          resultDiv.textContent = '‚úÖ ƒê√öNG';
          resultDiv.className = 'status ok';
        } else if(decision.verdict === 'date_match_batch_diff'){
          resultDiv.textContent = '‚ö†Ô∏è ƒê√öNG HSD, L·ªÜCH BATCH';
          resultDiv.className = 'status warn';
        } else {
          resultDiv.textContent = '‚ùå SAI';
          resultDiv.className = 'status fail';
        }

        playSound(decision.verdict === 'exact');
        if (decision.verdict === 'exact' && "vibrate" in navigator) navigator.vibrate(200);
      } finally {
        procMat.delete();
        ocrBusy = false;
      }
    }
    $('#captureBtn').addEventListener('click', captureOnce);

    /* ======= Auto Scan ======= */
    $('#toggleAuto').addEventListener('click', async function(){
      autoScan = !autoScan;
      this.textContent = 'Auto Scan: ' + (autoScan? 'ON':'OFF');

      if(autoScan){
        const loop = async()=>{
          if(!autoScan) return;
          if(!ocrBusy){
            const procMat = processFrame();
            if(procMat){
              ocrBusy = true;
              try{
                const cleaned = await runTesseract(procMat);
                const targets = $('#dateList').value.split('\n').map(v=>v.trim()).filter(Boolean);
                const {best, dist} = bestFuzzy(targets, cleaned);
                const decision = evaluateDecision(cleaned, targets);

                const info = best ? `${cleaned} ‚âà ${best} (score ${dist.toFixed(2)})` : cleaned;
                ocrTextDiv.textContent = `[got:${decision.gotDate||'‚Äî'} vs exp:${decision.expectedDate||'‚Äî'}] ${info}`;

                if(decision.verdict === 'exact'){
                  resultDiv.textContent = '‚úÖ ƒê√öNG';
                  resultDiv.className = 'status ok';
                } else if(decision.verdict === 'date_match_batch_diff'){
                  resultDiv.textContent = '‚ö†Ô∏è ƒê√öNG HSD, L·ªÜCH BATCH';
                  resultDiv.className = 'status warn';
                } else {
                  resultDiv.textContent = '‚ùå SAI';
                  resultDiv.className = 'status fail';
                }

                playSound(decision.verdict === 'exact');

                if (decision.verdict === 'exact'){
                  if ("vibrate" in navigator) navigator. vibrate(200);
                  autoScan = false;
                  $('#toggleAuto').textContent = 'Auto Scan: OFF';
                }
              } finally {
                procMat.delete();
                ocrBusy = false;
              }
            }
          }
          if(autoScan) autoTimer = setTimeout(loop, 500);
        };
        loop();
      } else {
        if(autoTimer) clearTimeout(autoTimer);
      }
    });

    // Unlock audio cho iPhone (why: y√™u c·∫ßu gesture tr∆∞·ªõc khi play)
    function unlockAudio() {
      const correct = document.getElementById("soundCorrect");
      const wrong = document.getElementById("soundWrong");
      correct.volume = 1.0; wrong.volume = 1.0;
      correct.currentTime = 0; wrong.currentTime = 0;
      correct.play().catch(()=>{});
      wrong.play().catch(()=>{});
      document.removeEventListener("touchstart", unlockAudio);
      document.removeEventListener("click", unlockAudio);
    }
    document.addEventListener("touchstart", unlockAudio, { once: true });
    document.addEventListener("click", unlockAudio, { once: true });
  </script>

  <!-- √Çm thanh b√°o hi·ªáu -->
  <audio id="soundCorrect" preload="auto">
    <source src="https://actions.google.com/sounds/v1/alarms/beep_short.mp3" type="audio/mp3">
  </audio>
  <audio id="soundWrong" preload="auto">
    <source src="https://actions.google.com/sounds/v1/alarms/beep_buzzer.mp3" type="audio/mp3">
  </audio>
</body>
</html>
