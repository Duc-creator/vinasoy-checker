<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>OCR Date Code Scanner</title>
<style>
  body { font-family: sans-serif; }
  canvas { border: 1px solid #ccc; }
  #controls { margin-bottom: 10px; }
  .preview { display: inline-block; margin: 5px; }
</style>
</head>
<body>

<div id="controls">
  <label>Hạn sử dụng (tháng): <select id="shelfLife"><option value="6">6</option><option value="12">12</option></select></label>
  <label>Mã lô: <input id="batchCode" maxlength="3"></label>
  <button onclick="generateDateCodes()">Tạo danh sách date</button>
  <button onclick="openCamera()">Bật Camera</button>
  <button onclick="capture()">Chụp</button>
  <button onclick="toggleAutoScan()">Auto Scan</button>
</div>

<div>
  <video id="video" autoplay playsinline width="640" height="480"></video>
  <canvas id="overlay" width="640" height="480"></canvas>
</div>

<div class="preview">
  <h3>Crop</h3>
  <canvas id="cropPrev" width="200" height="60"></canvas>
</div>
<div class="preview">
  <h3>Processed</h3>
  <canvas id="procPrev" width="200" height="60"></canvas>
</div>

<h3>Kết quả OCR</h3>
<pre id="result"></pre>

<canvas id="rawCanvas" width="640" height="480" style="display:none"></canvas>

<script src="https://docs.opencv.org/4.x/opencv.js"></script>
<script src="https://unpkg.com/tesseract.js@4/dist/tesseract.min.js"></script>

<script>
let cvReady = false, autoScan=false, dateCodes=[];

// OpenCV ready
function onOpenCvReady(){ cvReady = true; }
window.Module = { onRuntimeInitialized: onOpenCvReady };

function openCamera(){
  navigator.mediaDevices.getUserMedia({video:true}).then(s=>{
    video.srcObject = s;
  });
}

// ROI fixed
function getRoi(){
  let x=100, y=200, w=400, h=80;
  return {x,y,w,h};
}

// Hiển thị preview
function drawPreviews(cropMat, procMat){
  const cCanvas = cropPrev; const cCtx = cCanvas.getContext('2d');
  const tmp1 = document.createElement('canvas'); tmp1.width=cropMat.cols; tmp1.height=cropMat.rows;
  cv.imshow(tmp1, cropMat);
  cCtx.clearRect(0,0,cCanvas.width,cCanvas.height);
  cCtx.drawImage(tmp1,0,0,cCanvas.width,cCanvas.height);

  const pCanvas = procPrev; const pCtx = pCanvas.getContext('2d');
  const tmp2 = document.createElement('canvas'); tmp2.width=procMat.cols; tmp2.height=procMat.rows;
  cv.imshow(tmp2, procMat);
  pCtx.clearRect(0,0,pCanvas.width,pCanvas.height);
  pCtx.drawImage(tmp2,0,0,pCanvas.width,pCanvas.height);
}

// Tiền xử lý ảnh
function processFrame(){
  if(!cvReady || video.readyState<2) return null;
  const rctx = rawCanvas.getContext('2d');
  rctx.drawImage(video, 0, 0, rawCanvas.width, rawCanvas.height);
  let src = cv.imread(rawCanvas);
  const {x,y,w,h} = getRoi();
  let roi = src.roi(new cv.Rect(x,y,w,h));

  let gray = new cv.Mat();
  cv.cvtColor(roi, gray, cv.COLOR_RGBA2GRAY, 0);
  let up = new cv.Mat();
  cv.resize(gray, up, new cv.Size(0,0), 3, 3, cv.INTER_CUBIC);
  let blur = new cv.Mat();
  cv.GaussianBlur(up, blur, new cv.Size(3,3), 0);
  let bin = new cv.Mat();
  cv.adaptiveThreshold(blur, bin, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 21, 10);
  let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(2,2));
  let opened = new cv.Mat();
  cv.morphologyEx(bin, opened, cv.MORPH_OPEN, kernel);
  let sharp = new cv.Mat();
  let openedBlur = new cv.Mat();
  cv.GaussianBlur(opened, openedBlur, new cv.Size(0,0), 1.0);
  cv.addWeighted(opened, 1.5, openedBlur, -0.5, 0, sharp);
  const mean = cv.mean(sharp)[0];
  let proc = new cv.Mat();
  if(mean < 127){ cv.bitwise_not(sharp, proc); } else { proc = sharp.clone(); }

  drawPreviews(roi, proc);

  src.delete(); roi.delete(); gray.delete(); up.delete(); blur.delete(); bin.delete(); opened.delete(); kernel.delete(); openedBlur.delete();
  return proc;
}

// OCR với regex + sửa lỗi
async function runOCR(procMat){
  const tmpCanvas = document.createElement('canvas');
  tmpCanvas.width = procMat.cols; tmpCanvas.height = procMat.rows;
  cv.imshow(tmpCanvas, procMat);
  procMat.delete();

  let { data:{ text } } = await Tesseract.recognize(tmpCanvas, 'eng', { tessedit_char_whitelist: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' });
  text = text.replace(/\s+/g, ' ').trim();
  const regex = /^\d{6} \d{3}[A-I][1-7]$/;

  if(regex.test(text)){
    return text;
  } else {
    // sửa lỗi nếu lệch 1–2 ký tự
    let chars = text.split('');
    if(chars.length >= 11){
      const tenth = chars[9]; 
      if(!/[A-I]/.test(tenth)) chars[9] = 'A'; // giả sử chọn A nếu sai
    }
    const fixed = chars.join('');
    if(regex.test(fixed)) return fixed;
  }
  return null;
}

function capture(){
  const proc = processFrame();
  if(!proc) return;
  runOCR(proc).then(code=>{
    result.textContent = code ? `✅ ${code}` : '❌ Không khớp';
  });
}

function toggleAutoScan(){
  autoScan = !autoScan;
  if(autoScan) loopScan();
}

function loopScan(){
  if(!autoScan) return;
  const proc = processFrame();
  if(proc){
    runOCR(proc).then(code=>{
      result.textContent = code ? `✅ ${code}` : '❌';
    });
  }
  setTimeout(loopScan, 450);
}

function generateDateCodes(){
  dateCodes = [];
  const shelfLife = parseInt(document.getElementById('shelfLife').value);
  const batchCode = document.getElementById('batchCode').value;
  // Tạo danh sách giả lập
  dateCodes.push("150825 123A1");
  dateCodes.push("160825 123B2");
  alert("Đã tạo " + dateCodes.length + " code");
}
</script>
</body>
</html>
