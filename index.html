<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
<title>OCR Date Checker Vinasoy (NƒêT) ‚Äî Optimized</title>
<style>
:root{ --w: 340px; --h: 240px; }
body{ font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#f6f7f9; margin:0; }
.wrap{ max-width:720px; margin:0 auto; padding:14px; }
h1{ font-size:20px; margin:10px 0; }
.row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
label{ font-size:14px; color:#333; }
input, select, button, textarea{ font-size:14px; padding:10px; border-radius:10px; border:1px solid #dfe3ea; background:#fff; }
button{ cursor:pointer; border:none; background:#0a7cff; color:#fff; box-shadow:0 4px 12px rgba(10,124,255,.2); }
button:active{ transform:translateY(1px); }
textarea{ width:100%; min-height:120px; }
.camera{ position:relative; display:inline-block; }
video{ width:var(--w); height:var(--h); object-fit:cover; border-radius:12px; border:2px solid #e3e7ee; background:#000; }
#crossOverlay{ position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; display:block; }
.mini{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:8px 0; }
.status{ font-weight:700; font-size:16px; }
.ok{ color:#1f9d55; } .fail{ color:#e11d48; } .muted{ color:#6b7280; font-weight:500; }
canvas{ display:none; }
.preview{ display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap; margin-top:8px; }
.box{ background:#fff; border:1px solid #e5e7eb; border-radius:10px; padding:8px; }
.box h3{ margin:0 0 6px 0; font-size:13px; color:#374151; }
.box canvas{ display:block; width:220px; height:auto; border-radius:8px; }
.tip{ font-size:12px; color:#6b7280; }

.badge{ font-size:12px; padding:3px 8px; border-radius:999px; background:#eef2ff; color:#334155; border:1px solid #e5e7eb; }
</style>
</head>
<body>
<div class="wrap">
<h1>OCR Date Checker Vinasoy (NƒêT)</h1>

<div class="row">
  <label>H·∫°n d√πng (th√°ng)
    <select id="shelfLife"><option value="6">6</option><option value="9">9</option><option value="10">10</option></select>
  </label>
  <label>M√£ l√¥ (3 k√Ω t·ª±)
    <input id="batchCode" maxlength="3" placeholder="VD: 086" />
  </label>
  <label>Th·ª© h√¥m nay
    <input id="weekday" readonly style="width:60px" />
  </label>
  <label class="mini"><input type="checkbox" id="singleLineCheck" /> Ch·ªâ 1 line</label>
  <label id="lineSelectWrapper" style="display:none;">Line
    <select id="lineSelect"><option>A</option><option>B</option><option>C</option><option>D</option><option>E</option><option>F</option><option>G</option><option>H</option><option>I</option></select>
  </label>
  <button id="generateBtn">T·∫°o danh s√°ch date</button>
</div>

<textarea id="dateList" placeholder="Danh s√°ch date code..."></textarea>

<div class="mini">
  <button id="openBtn">B·∫≠t camera</button>
  <button id="captureBtn">üì∑ Ch·ª•p & OCR</button>
  <button id="toggleAuto">Auto Scan: OFF</button>
  <span id="loader" class="muted">OpenCV: ‚Äî | Tesseract: ‚Äî</span>
  <span id="qos" class="badge">Stable: ‚Äî | Sharp: ‚Äî | Œî: ‚Äî</span>
</div>

<div class="camera">
  <video id="video" playsinline muted></video>
  <canvas id="crossOverlay"></canvas>
</div>

<div class="mini">
  <span>K·∫øt qu·∫£:</span>
  <span id="result" class="status muted">‚Äî</span>
</div>
<div id="ocrText" class="tip"></div>

<canvas id="rawCanvas"></canvas>
<canvas id="cropCanvas"></canvas>
<canvas id="procCanvas"></canvas>

<div class="preview">
  <div class="box"><h3>Crop</h3><canvas id="cropPreview" width="220" height="100"></canvas></div>
  <div class="box"><h3>Processed</h3><canvas id="procPreview" width="220" height="100"></canvas></div>
</div>

<p class="tip">M·∫πo: ƒê·∫∑t ƒë·ªëi t∆∞·ª£ng ngay t·∫°i d·∫•u c·ªông ƒë·ªÉ OCR nhanh v√† ch√≠nh x√°c. (Ch·ªâ OCR khi khung h√¨nh ·ªïn ƒë·ªãnh & ƒë·ªß n√©t)</p>
</div>

<script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()"></script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
<script>
/* ====== Helpers & State ====== */
const $ = (s) => document.querySelector(s);
const video = $('#video');
const crossOverlay = $('#crossOverlay');
const resultDiv = $('#result');
const ocrTextDiv = $('#ocrText');
const rawCanvas = $('#rawCanvas');
const loader = $('#loader');
const qos = $('#qos');

let autoScan = false, autoTimer = null;
let cvReady = false;
let lastGraySmall = null;
let isOcrRunning = false;
let lastResults = []; // sliding window for consensus
const CONSENSUS_WIN = 7;
const CONSENSUS_REQ = 3;
const OCR_INTERVAL_MS = 350; // rate limit OCR
const MOTION_THRESH = 6.0;   // c√†ng th·∫•p c√†ng ‚Äú·ªïn ƒë·ªãnh‚Äù
const SHARP_THRESH  = 45.0;  // c√†ng cao c√†ng ‚Äún√©t‚Äù
let lastOcrTs = 0;

// iOS Audio ‚Äúting‚Äù
let tingAudio = null;
function initTingAudio(){
  // Ph·∫£i g√°n bi·∫øn to√†n c·ª•c v√† play trong s·ª± ki·ªán do ng∆∞·ªùi d√πng k√≠ch (click)
  tingAudio = new Audio('https://actions.google.com/sounds/v1/alarms/beep_short.mp3');
  tingAudio.preload = 'auto';
  tingAudio.volume = 1.0;
}
function playTing(){
  if(tingAudio){
    tingAudio.currentTime = 0;
    tingAudio.play().catch(()=>{});
  }
}

/* ====== Crosshair Overlay ====== */
function drawCross(){
  const ctx = crossOverlay.getContext('2d');
  ctx.clearRect(0,0,crossOverlay.width,crossOverlay.height);
  ctx.strokeStyle = 'rgba(255,0,0,0.95)';
  ctx.lineWidth = 3;
  const centerX = crossOverlay.width / 2;
  const centerY = crossOverlay.height / 2;
  const vLen = 50, hLen = 50;
  ctx.beginPath();
  ctx.moveTo(centerX - hLen/2, centerY);
  ctx.lineTo(centerX + hLen/2, centerY);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(centerX, centerY - vLen/2);
  ctx.lineTo(centerX, centerY + vLen/2);
  ctx.stroke();
}

/* ====== Weekday ====== */
function updateWeekday(){
  const d=new Date();
  const day=d.getDay(); // 0..6 (CN..T7)
  const weekday=(day===0)?1:day+1; // mapping theo th√≥i quen tr∆∞·ªõc ƒë√≥
  $('#weekday').value=weekday;
}
updateWeekday();

/* ====== Date code generator ====== */
function addMonthsAdjust(date, months){
  const y=date.getFullYear(), m=date.getMonth(), day=date.getDate();
  const nd=new Date(y, m+months, 1);
  const last=new Date(nd.getFullYear(), nd.getMonth()+1, 0).getDate();
  return new Date(nd.getFullYear(), nd.getMonth(), Math.min(day,last));
}
$('#generateBtn').addEventListener('click', ()=>{
  const batchCode = $('#batchCode').value.trim();
  const weekday = $('#weekday').value;
  const shelfMonths = parseInt($('#shelfLife').value);
  const singleLine = $('#singleLineCheck').checked;
  const line = $('#lineSelect').value;
  if(batchCode.length!==3){ alert('Nh·∫≠p m√£ l√¥ 3 k√Ω t·ª±'); return; }
  const expiry = addMonthsAdjust(new Date(), shelfMonths);
  const dd=String(expiry.getDate()).padStart(2,'0');
  const mm=String(expiry.getMonth()+1).padStart(2,'0');
  const yy=String(expiry.getFullYear()).slice(2);
  const dateCode = dd+mm+yy;
  let res='';
  if(singleLine){ res = `${dateCode} ${batchCode}${line}${weekday}`; }
  else{ ['A','B','C','D','E','F','G','H','I'].forEach(L=>res+=`${dateCode} ${batchCode}${L}${weekday}\n`); res=res.trim(); }
  $('#dateList').value = res;
});
$('#singleLineCheck').addEventListener('change', function(){ $('#lineSelectWrapper').style.display = this.checked? 'inline-block':'none'; });

/* ====== Camera ====== */
async function openCamera(){
  try{
    if(!tingAudio) initTingAudio(); // unlock audio on click
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: 'environment' } }, audio:false
    });
    video.srcObject = stream;
    await video.play();

    // sync overlay & raw canvas
    crossOverlay.width = video.clientWidth;
    crossOverlay.height = video.clientHeight;
    rawCanvas.width = video.videoWidth;
    rawCanvas.height = video.videoHeight;
    drawCross();
  }catch(err){ alert('Kh√¥ng m·ªü ƒë∆∞·ª£c camera: '+err.message); }
}
$('#openBtn').addEventListener('click', openCamera);

/* ====== OpenCV Ready ====== */
function onOpenCvReady(){
  cv['onRuntimeInitialized']=()=>{
    cvReady=true;
    loader.textContent='OpenCV: ready | Tesseract: loading...';
    // Warm-up Tesseract
    Tesseract.create({
      workerPath: Tesseract.defaultWorkerPath,
      langPath: Tesseract.defaultLangPath,
      corePath: Tesseract.defaultCorePath,
    }); // no await; just to trigger WASM fetch
    setTimeout(()=>loader.textContent='OpenCV: ready | Tesseract: ready',700);
  };
}

/* ====== ROI t·ª´ d·∫•u c·ªông ====== */
function getRoiFromPlusSign(){
  const centerX = video.videoWidth / 2;
  const centerY = video.videoHeight / 2;
  const roiWidth = 260;   // tƒÉng nh·∫π b·ªÅ r·ªông ƒë·ªÉ ‚Äúd·ªÖ cƒÉn‚Äù
  const roiHeight = 90;   // cao v·ª´a ƒë·ªß
  const x = Math.max(0, Math.round(centerX - roiWidth / 2));
  const y = Math.max(0, Math.round(centerY - roiHeight / 2));
  return {x, y, w:roiWidth, h:roiHeight};
}

/* ====== Ch·ªâ s·ªë ch·∫•t l∆∞·ª£ng khung h√¨nh ====== */
function laplacianVariance(gray){
  let lap = new cv.Mat();
  cv.Laplacian(gray, lap, cv.CV_64F);
  const m = cv.meanStdDev(lap);
  const variance = m.stddev.at(0) * m.stddev.at(0);
  lap.delete(); m.mean.delete(); m.stddev.delete();
  return variance;
}
function motionDelta(currSmall){
  if(!lastGraySmall) return 999; // coi nh∆∞ "m·ªõi"
  let diff = new cv.Mat();
  cv.absdiff(currSmall, lastGraySmall, diff);
  const mean = cv.mean(diff)[0];
  diff.delete();
  return mean;
}

/* ====== X·ª≠ l√Ω frame (m·∫°nh) ====== */
function processFrame(){
  if(!cvReady || video.readyState < 2) return null;

  const rctx = rawCanvas.getContext('2d');
  rctx.drawImage(video, 0, 0, rawCanvas.width, rawCanvas.height);

  // Read full frame
  let src = cv.imread(rawCanvas);
  const {x,y,w,h} = getRoiFromPlusSign();
  let roi = src.roi(new cv.Rect(x,y,w,h));

  // Gray
  let gray = new cv.Mat();
  cv.cvtColor(roi, gray, cv.COLOR_RGBA2GRAY, 0);

  // --- QoS: motion & sharpness ---
  // downscale for motion
  let small = new cv.Mat();
  cv.resize(gray, small, new cv.Size(80, Math.round(80*gray.rows/gray.cols)), 0,0, cv.INTER_AREA);
  const delta = motionDelta(small);
  const sharp = laplacianVariance(gray);
  qos.textContent = `Stable: ${delta.toFixed(1)} | Sharp: ${sharp.toFixed(1)} | Œî: ${Date.now()-lastOcrTs}ms`;
  if(lastGraySmall) lastGraySmall.delete();
  lastGraySmall = small.clone();

  // Enhance: CLAHE (tƒÉng t∆∞∆°ng ph·∫£n c·ª•c b·ªô)
  let clahe = new cv.CLAHE(2.0, new cv.Size(8,8));
  clahe.apply(gray, gray);

  // Resize up
  let up = new cv.Mat();
  cv.resize(gray, up, new cv.Size(gray.cols*3, gray.rows*3), 0, 0, cv.INTER_CUBIC);

  // Noise reduce
  let blur = new cv.Mat();
  cv.medianBlur(up, blur, 3);

  // Morph close ƒë·ªÉ n·ªëi n√©t m·∫£nh
  let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(2,2));
  let closed = new cv.Mat();
  cv.morphologyEx(blur, closed, cv.MORPH_CLOSE, kernel);

  // Adaptive threshold
  let bin = new cv.Mat();
  cv.adaptiveThreshold(closed, bin, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 21, 10);

  // Auto invert n·∫øu n·ªÅn ƒëen ch·ªØ tr·∫Øng
  let proc = new cv.Mat();
  const mean = cv.mean(bin)[0];
  if(mean < 127){ cv.bitwise_not(bin, proc); } else { proc = bin.clone(); }

  // Preview
  cv.imshow($('#cropPreview'), roi);
  cv.imshow($('#procPreview'), proc);

  src.delete(); roi.delete(); /* gray gi·ªØ l·∫°i bi·∫øn tham chi·∫øu ƒë√£ b·ªã overwritte n */
  // cleanup
  gray.delete(); up.delete(); blur.delete(); closed.delete(); kernel.delete(); bin.delete();
  return {proc, delta, sharp};
}

/* ====== H·∫≠u x·ª≠ l√Ω & consensus ====== */
function postProcess(text){
  // Chu·∫©n d·∫°ng: "DDMMYY XXXLw" (6 s·ªë, 1 space, 3 s·ªë, 1 ch·ªØ A-I, 1 s·ªë weekday 1-7)
  const regex = /^\d{6} \d{3}[A-I][1-7]$/;
  let t = text.replace(/\s+/g,' ').trim().toUpperCase();
  t = t.replace(/[^0-9A-I ]/g,'');
  if(regex.test(t)) return t;

  // S·ª≠a nh·∫π ‚â§2 l·ªói th∆∞·ªùng g·∫∑p (space thi·∫øu, O->0, I->1 vv.)
  let chars = t.split('');
  let changes = 0;
  // b·∫£o v·ªá v·ªã tr√≠
  for(let i=0;i<chars.length;i++){
    if(i>=0 && i<=5 && !/[0-9]/.test(chars[i])){ chars[i]='0'; changes++; }
    if(i===6 && chars[i]!==' '){ chars[i]=' '; changes++; }
    if(i>=7 && i<=9 && !/[0-9]/.test(chars[i])){ chars[i]='0'; changes++; }
    if(i===10 && !/[A-I]/.test(chars[i])){ chars[i]='A'; changes++; }
    if(i===11 && !/[1-7]/.test(chars[i])){ chars[i]='1'; changes++; }
  }
  const fixed = chars.join('');
  return (changes<=2 && regex.test(fixed)) ? fixed : t;
}
function addConsensus(res){
  lastResults.push(res);
  if(lastResults.length > CONSENSUS_WIN) lastResults.shift();
  const counts = {};
  lastResults.forEach(r => counts[r] = (counts[r]||0)+1);
  const top = Object.entries(counts).sort((a,b)=>b[1]-a[1])[0];
  return (top && top[1] >= CONSENSUS_REQ) ? top[0] : null;
}

/* ====== Tesseract OCR ====== */
async function runTesseract(procMat){
  const tmpCanvas = document.createElement('canvas');
  tmpCanvas.width = procMat.cols; tmpCanvas.height = procMat.rows;
  cv.imshow(tmpCanvas, procMat);

  const { data: { text } } = await Tesseract.recognize(tmpCanvas, 'eng', {
    tessedit_char_whitelist: '0123456789ABCDEFGHI ',
    preserve_interword_spaces: '1',
    user_defined_dpi: '300',
    tessedit_pageseg_mode: '7',
    psm: 7,
    load_system_dawg: 'F',
    load_freq_dawg: 'F'
  });
  return postProcess(text);
}

/* ====== ƒê√°nh gi√° & hi·ªán k·∫øt qu·∫£ ====== */
function evaluateAndDisplay(candidate){
  const targets = $('#dateList').value.split('\n').map(v=>v.trim()).filter(Boolean);
  const matched = targets.includes(candidate);
  resultDiv.textContent = matched ? '‚úÖ ƒê√öNG' : '‚ùå SAI';
  resultDiv.className = 'status ' + (matched ? 'ok' : 'fail');
  ocrTextDiv.textContent = candidate;
  if (matched) {
    if ("vibrate" in navigator) navigator.vibrate(200);
    playTing();
  }
  return matched;
}

/* ====== Ch·ª•p 1 l·∫ßn ====== */
async function captureOnce(){
  if(isOcrRunning) return;
  const bundle = processFrame();
  if(!bundle) return;
  const {proc, delta, sharp} = bundle;

  // Ch·ªâ OCR khi khung h√¨nh ƒë·ªß ·ªïn ƒë·ªãnh & n√©t
  if(delta > MOTION_THRESH || sharp < SHARP_THRESH){
    proc.delete();
    return;
  }

  isOcrRunning = true;
  try{
    const cleaned = await runTesseract(proc);
    const stable = addConsensus(cleaned) || cleaned;
    evaluateAndDisplay(stable);
  }catch(e){ console.warn(e); }
  finally{
    isOcrRunning = false;
    proc.delete();
  }
}
$('#captureBtn').addEventListener('click', captureOnce);

/* ====== Auto Scan v√≤ng l·∫∑p ====== */
$('#toggleAuto').addEventListener('click', async function(){
  autoScan = !autoScan; this.textContent = 'Auto Scan: ' + (autoScan? 'ON':'OFF');
  if(autoScan){
    const loop = async()=>{
      if(!autoScan) return;
      // Rate limit
      const now = Date.now();
      if(now - lastOcrTs < OCR_INTERVAL_MS){
        autoTimer = setTimeout(loop, 40);
        return;
      }

      const bundle = processFrame();
      if(bundle){
        const {proc, delta, sharp} = bundle;
        // Ch·ªâ OCR khi ‚Äú·ªïn ƒë·ªãnh & n√©t‚Äù
        if(delta <= MOTION_THRESH && sharp >= SHARP_THRESH && !isOcrRunning){
          isOcrRunning = true;
          lastOcrTs = now;
          try{
            const cleaned = await runTesseract(proc);
            const stable = addConsensus(cleaned) || cleaned;
            const ok = evaluateAndDisplay(stable);
            if (ok){ autoScan = false; $('#toggleAuto').textContent = 'Auto Scan: OFF'; }
          }catch(e){ console.warn(e); }
          finally{
            isOcrRunning = false;
          }
        }
        proc.delete();
      }
      if(autoScan) autoTimer = setTimeout(loop, 60);
    };
    loop();
  } else { if(autoTimer) clearTimeout(autoTimer); }
});

/* ====== Resize overlay khi layout ƒë·ªïi ====== */
window.addEventListener('resize', ()=>{
  if(!video.videoWidth) return;
  crossOverlay.width = video.clientWidth;
  crossOverlay.height = video.clientHeight;
  drawCross();
});
</script>
</body>
</html>
