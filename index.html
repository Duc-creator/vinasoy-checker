<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
  <title>OCR Date Checker (OpenCV.js + Tesseract)</title>
  <style>
    :root{ --w: 340px; --h: 240px; }
    body{ font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#f6f7f9; margin:0; }
    .wrap{ max-width:720px; margin:0 auto; padding:14px; }
    h1{ font-size:20px; margin:10px 0; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    label{ font-size:14px; color:#333; }
    input, select, button, textarea{ font-size:14px; padding:10px; border-radius:10px; border:1px solid #dfe3ea; background:#fff; }
    button{ cursor:pointer; border:none; background:#0a7cff; color:#fff; box-shadow:0 4px 12px rgba(10,124,255,.2); }
    button:active{ transform:translateY(1px); }
    button:disabled{ background:#a0aec0; cursor:not-allowed; box-shadow:none; }
    textarea{ width:100%; min-height:120px; }
    .camera{ position:relative; display:inline-block; }
    video{ width:var(--w); height:var(--h); object-fit:cover; border-radius:12px; border:2px solid #e3e7ee; background:#000; }
    #overlay{ position:absolute; border:2px dashed rgba(255,62,62,.9); border-radius:8px; pointer-events:none; width:160px; height:56px; top:50%; left:50%; transform:translate(-50%,-50%); box-shadow:0 0 12px rgba(255,62,62,.35); }
    .mini{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:8px 0; }
    .status{ font-weight:700; font-size:16px; }
    .ok{ color:#1f9d55; } .fail{ color:#e11d48; } .muted{ color:#6b7280; font-weight:500; }
    canvas{ display:none; }
    .preview{ display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap; margin-top:8px; }
    .box{ background:#fff; border:1px solid #e5e7eb; border-radius:10px; padding:8px; }
    .box h3{ margin:0 0 6px 0; font-size:13px; color:#374151; }
    .box canvas{ display:block; width:220px; height:auto; border-radius:8px; }
    .tip{ font-size:12px; color:#6b7280; }
  </style>
</head>
<body>
<div class="wrap">
  <h1>OCR Date Checker (OpenCV.js + Tesseract)</h1>

  <div class="row">
    <label>H·∫°n d√πng (th√°ng)
      <select id="shelfLife">
        <option value="6">6</option>
        <option value="9">9</option>
        <option value="10">10</option>
      </select>
    </label>
    <label>M√£ l√¥ (3 k√Ω t·ª±)
      <input id="batchCode" maxlength="3" placeholder="VD: 086" />
    </label>
    <label>Th·ª© h√¥m nay
      <input id="weekday" readonly style="width:60px" />
    </label>
    <label class="mini"><input type="checkbox" id="singleLineCheck" /> Ch·ªâ 1 line</label>
    <label id="lineSelectWrapper" style="display:none;">Line
      <select id="lineSelect"><option>A</option><option>B</option><option>C</option><option>D</option><option>E</option><option>F</option><option>G</option><option>H</option><option>I</option></select>
    </label>
    <button id="generateBtn">T·∫°o danh s√°ch date</button>
  </div>

  <textarea id="dateList" placeholder="Danh s√°ch date code..."></textarea>

  <div class="mini">
    <button id="openBtn">B·∫≠t camera</button>
    <button id="captureBtn" disabled>üì∑ Ch·ª•p & OCR</button>
    <button id="toggleAuto" disabled>Auto Scan: OFF</button>
    <span id="loader" class="muted">ƒêang t·∫£i model...</span>
  </div>

  <div class="camera">
    <video id="video" playsinline muted></video>
    <div id="overlay" title="K√©o khung n√†y ƒë·∫øn v√πng c√≥ m√£ (gi·ªØ gi·ªØa khung)"></div>
  </div>

  <div class="mini">
    <span>K·∫øt qu·∫£:</span>
    <span id="result" class="status muted">‚Äî</span>
  </div>
  <div id="ocrText" class="tip"></div>

  <canvas id="rawCanvas"></canvas>
  <canvas id="cropCanvas"></canvas>
  <canvas id="procCanvas"></canvas>

  <div class="preview">
    <div class="box"><h3>Crop</h3><canvas id="cropPreview" width="220" height="100"></canvas></div>
    <div class="box"><h3>Processed</h3><canvas id="procPreview" width="220" height="100"></canvas></div>
  </div>

  <p class="tip">M·∫πo: ƒê·∫∑t khung ƒë·ªè v·ª´a kh√≠t d√£y m√£ (v√≠ d·ª•: <b>130226 093C4</b>), gi·ªØ m√°y ch·∫Øc tay, ƒë·∫£m b·∫£o ƒë·ªß s√°ng.</p>
</div>

<script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()"></script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<script>
const $ = s => document.querySelector(s);
let cvReady = false, tessReady = false;
const video = $('#video');
const overlay = $('#overlay');
const resultDiv = $('#result');
const ocrTextDiv = $('#ocrText');
const rawCanvas = $('#rawCanvas');
const cropCanvas = $('#cropCanvas');
const procCanvas = $('#procCanvas');
const cropPrev = $('#cropPreview');
const procPrev = $('#procPreview');
const loader = $('#loader');

function updateStatus(){
  if(cvReady && tessReady){
    loader.textContent = '‚úÖ C·∫£ OpenCV & Tesseract ƒë√£ s·∫µn s√†ng';
    $('#captureBtn').disabled = false;
    $('#toggleAuto').disabled = false;
  } else {
    $('#captureBtn').disabled = true;
    $('#toggleAuto').disabled = true;
    if(!cvReady && !tessReady) loader.textContent = '‚è≥ ƒêang t·∫£i OpenCV & Tesseract...';
    else if(!cvReady) loader.textContent = '‚è≥ ƒêang t·∫£i OpenCV...';
    else if(!tessReady) loader.textContent = '‚è≥ ƒêang t·∫£i Tesseract...';
  }
}

function onOpenCvReady(){
  cv['onRuntimeInitialized'] = ()=>{ cvReady = true; updateStatus(); };
}

const worker = Tesseract.createWorker();
(async()=>{
  await worker.load();
  await worker.loadLanguage('eng');
  await worker.initialize('eng');
  await worker.setParameters({ 'tessedit_pageseg_mode': '7', 'preserve_interword_spaces': '1' });
  tessReady = true; updateStatus();
})();

updateStatus();

function updateWeekday(){
  const d=new Date();
  const day=d.getDay();
  const weekday=(day===0)?1:day+1;
  $('#weekday').value=weekday;
}
updateWeekday();

function addMonthsAdjust(date, months){
  const y=date.getFullYear();
  const m=date.getMonth();
  const day=date.getDate();
  const nm=m+months;
  const nd=new Date(y, nm, 1);
  const last=new Date(nd.getFullYear(), nd.getMonth()+1, 0).getDate();
  return new Date(nd.getFullYear(), nd.getMonth(), Math.min(day,last));
}

$('#generateBtn').addEventListener('click', ()=>{
  const batchCode = $('#batchCode').value.trim();
  const weekday = $('#weekday').value;
  const shelfMonths = parseInt($('#shelfLife').value);
  const singleLine = $('#singleLineCheck').checked;
  const line = $('#lineSelect').value;
  if(batchCode.length!==3){ alert('Nh·∫≠p m√£ l√¥ 3 k√Ω t·ª±'); return; }
  const expiry = addMonthsAdjust(new Date(), shelfMonths);
  const dd=String(expiry.getDate()).padStart(2,'0');
  const mm=String(expiry.getMonth()+1).padStart(2,'0');
  const yy=String(expiry.getFullYear()).slice(2);
  const dateCode = dd+mm+yy;
  let res='';
  if(singleLine){ res = `${dateCode} ${batchCode}${line}${weekday}`; }
  else{ ['A','B','C','D','E','F','G','H','I'].forEach(L=>res+=`${dateCode} ${batchCode}${L}${weekday}\n`); res=res.trim(); }
  $('#dateList').value = res;
});
$('#singleLineCheck').addEventListener('change', function(){ $('#lineSelectWrapper').style.display = this.checked? 'inline-block':'none'; });

async function openCamera(){
  try{
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { ideal: 'environment' }, width: { ideal: 1280 }, height: { ideal: 720 }}, audio:false });
    video.srcObject = stream; await video.play();
    rawCanvas.width = video.videoWidth; rawCanvas.height = video.videoHeight;
    cropCanvas.width = 320; cropCanvas.height = 120;
    procCanvas.width = 640; procCanvas.height = 240;
  }catch(err){ alert('Kh√¥ng m·ªü ƒë∆∞·ª£c camera: '+err.message); }
}
$('#openBtn').addEventListener('click', openCamera);

function getRoi(){
  const vRect = video.getBoundingClientRect();
  const oRect = overlay.getBoundingClientRect();
  const scaleX = video.videoWidth / vRect.width;
  const scaleY = video.videoHeight / vRect.height;
  const x = Math.max(0, (oRect.left - vRect.left) * scaleX);
  const y = Math.max(0, (oRect.top - vRect.top) * scaleY);
  const w = Math.min(video.videoWidth - x, oRect.width * scaleX);
  const h = Math.min(video.videoHeight - y, oRect.height * scaleY);
  return {x:Math.round(x), y:Math.round(y), w:Math.round(w), h:Math.round(h)};
}

function drawPreviews(cropMat, procMat){
  const cCanvas = cropPrev; const cCtx=cCanvas.getContext('2d');
  const tmp1 = document.createElement('canvas'); tmp1.width=cropMat.cols; tmp1.height=cropMat.rows;
  cv.imshow(tmp1, cropMat); cCtx.clearRect(0,0,cCanvas.width,cCanvas.height); cCtx.drawImage(tmp1,0,0,cCanvas.width,cCanvas.height);
  const pCanvas = procPrev; const pCtx=pCanvas.getContext('2d');
  const tmp2 = document.createElement('canvas'); tmp2.width=procMat.cols; tmp2.height=procMat.rows;
  cv.imshow(tmp2, procMat); pCtx.clearRect(0,0,pCanvas.width,pCanvas.height); pCtx.drawImage(tmp2,0,0,pCanvas.width,pCanvas.height);
}

function processFrame(){
  if(!cvReady || video.readyState<2) return null;
  const rctx = rawCanvas.getContext('2d');
  rctx.drawImage(video, 0, 0, rawCanvas.width, rawCanvas.height);
  let src = cv.imread(rawCanvas);
  const {x,y,w,h} = getRoi();
  let roi = src.roi(new cv.Rect(x,y,w,h));
  let gray = new cv.Mat();
  cv.cvtColor(roi, gray, cv.COLOR_RGBA2GRAY, 0);
  let up = new cv.Mat();
  cv.resize(gray, up, new cv.Size(0,0), 3, 3, cv.INTER_CUBIC);
  let blur = new cv.Mat();
  cv.GaussianBlur(up, blur, new cv.Size(3,3), 0);
  let bin = new cv.Mat();
  cv.adaptiveThreshold(blur, bin, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 21, 10);
  let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(2,2));
  let opened = new cv.Mat();
  cv.morphologyEx(bin, opened, cv.MORPH_OPEN, kernel);
  let sharp = new cv.Mat();
  let openedBlur = new cv.Mat();
  cv.GaussianBlur(opened, openedBlur, new cv.Size(0,0), 1.0);
  cv.addWeighted(opened, 1.5, openedBlur, -0.5, 0, sharp);
  const mean = cv.mean(sharp)[0];
  let proc = new cv.Mat();
  if(mean > 127){ cv.bitwise_not(sharp, proc); } else { proc = sharp.clone(); }
  drawPreviews(roi, proc);
  cv.imshow(procCanvas, proc);
  src.delete(); roi.delete(); gray.delete(); up.delete(); blur.delete(); bin.delete(); opened.delete(); kernel.delete(); openedBlur.delete(); sharp.delete();
  return procCanvas;
}

function normalizeText(s){
  let t = s.trim().replace(/\s+/g,' ');
  t = t.replace(/O/g,'0').replace(/I/g,'1').replace(/l/g,'1').replace(/S/g,'5').replace(/B/g,'8');
  t = t.replace(/(\d{6})\s([0-9a-zA-Z]{5})/, (m,a,b)=> `${a} ${b.toUpperCase()}`);
  return t;
}

async function runOCR(canvasEl){
  const { data: { text } } = await worker.recognize(canvasEl, { tessedit_char_whitelist: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' });
  const cleaned = normalizeText(text);
  ocrTextDiv.textContent = cleaned;
  const targets = $('#dateList').value.split('\n').map(v=>v.trim()).filter(Boolean);
  const matched = targets.includes(cleaned);
  resultDiv.textContent = matched ? '‚úÖ ƒê√öNG' : '‚ùå SAI';
  resultDiv.className = 'status ' + (matched ? 'ok' : 'fail');
}

async function captureOnce(){
  const canvasEl = processFrame();
  if(canvasEl) await runOCR(canvasEl);
}
$('#captureBtn').addEventListener('click', captureOnce);

let autoScan = false, autoTimer = null;
$('#toggleAuto').addEventListener('click', async function(){
  autoScan = !autoScan; this.textContent = 'Auto Scan: ' + (autoScan? 'ON':'OFF');
  if(autoScan){
    const loop = async()=>{
      if(!autoScan) return;
      const canvasEl = processFrame();
      if(canvasEl) await runOCR(canvasEl);
      autoTimer = setTimeout(loop, 450);
    };
    loop();
  } else { if(autoTimer) clearTimeout(autoTimer); }
});
</script>
</body>
</html>
